#!/bin/bash

echo "SubmitJobs (c) 2024 Liwei Ji, Wolfgang Tichy"

# Execute and print the command
execute_command() {
    echo "\$ $@"
    "$@"
}
export -f execute_command

# ----------------
# Global Functions
# ----------------

# Generate a new directory name for a job
generate_new_directory_name() {
    # Base name for the new directory
    local base_name="${1}_r"

    # Check for existing directories matching the pattern
    if compgen -G "${base_name}[0-9][0-9][0-9][0-9]" > /dev/null; then
        # Find the highest-numbered directory
        local last_run=$(ls -d ${base_name}[0-9][0-9][0-9][0-9] 2>/dev/null | sort -V | tail -n 1)

        # Extract the numeric part of the last directory and increment it
        local last_index=${last_run##*${base_name}}
        local next_index=$((10#$last_index + 1))

        # Format the new index as a 4-digit number
        printf -v formatted_index "%04d" $next_index
        echo "${base_name}${formatted_index}"
    else
        # Default to the first directory if no matches
        echo "${base_name}0000"
    fi
}
export -f generate_new_directory_name

# Create a new job directory, move files inside, and launch jobs
create_and_organize_job_directory_and_launch_jobs() {
    local param_file=$1
    local job_name=$2
    local job_id=$3

    # Validate input arguments
    if [[ -z "$param_file" || -z "$job_name" || -z "$job_id" ]]; then
        echo "Error: Missing required arguments. Usage: create_and_organize_job_directory_and_launch_jobs <param_file> <job_name> <job_id>"
        exit 1
    fi

    # Generate a new directory name
    local job_output_dir=$(generate_new_directory_name "${job_name}")

    if [[ -d "$job_output_dir" ]]; then
        echo "Error: Directory '${job_output_dir}' already exists. Please check."
        exit 1
    fi

    execute_command mkdir -p "$job_output_dir" || { echo "Error: Failed to create directory $job_output_dir"; exit 1; }
    execute_command cp "$param_file" "$job_output_dir" || { echo "Error: Failed to copy $param_file to $job_output_dir"; exit 1; }
    execute_command mv stdout.txt "$job_output_dir" 2>/dev/null || echo "Warning: stdout.txt not found"
    execute_command mv stderr.txt "$job_output_dir" 2>/dev/null || echo "Warning: stderr.txt not found"
    # execute_command mv "$job_name.o$job_id" "$job_output_dir" 2>/dev/null || echo "Warning: $job_name.o$job_id not found"
    # execute_command mv "$job_name.e$job_id" "$job_output_dir" 2>/dev/null || echo "Warning: $job_name.e$job_id not found"

    execute_command cd "$job_output_dir" || { echo "Error: Failed to change directory to $job_output_dir"; exit 1; }

    # Launch jobs
    echo "======================================================================"
    echo "Launch MPI code..."
    echo "----------------------------------------------------------------------"
    echo "MPIRUN = $SUBMITJOBS_MPIRUN"
    echo
    echo "Job started on $(hostname) at $(date)"
    echo "======================================================================"

    time $SUBMITJOBS_MPIRUN

    if [ $? -ne 0 ]; then
      echo "Error: MPI job failed."
      exit 1
    fi

    echo "======================================================================"
    echo "Job Ended at $(date)"
}
export -f create_and_organize_job_directory_and_launch_jobs

# ---------------
# Local Functions
# ---------------

# Display usage instructions
display_usage() {
    echo "
USAGE:
  SubmitJobs <num_jobs> <executable> <param_file> [[nodes mpi_tasks omp_threads wall_time queue allocation] [subscript] [job_name]]

    Arguments:
      num_jobs:        Number of jobs to submit (e.g., 1,2,3,...:DependOnID).
      executable:      Path to the executable script or binary.
      param_file:      Path to the parameter file.
      nodes, mpi_tasks, omp_threads, wall_time, queue, allocation:
                       Optional job-specific arguments.
      subscript:       Submission script name (default: $default_subscript).
      job_name:        Custom job name (default: param_file without '.par').

DEFAULTS:
  subscript = $default_subscript
  job_name  = param_file without '.par'

NOTES:
  * Use 'SubScript-BareMetal' as subscript when specifying node-related options.
  * Custom job_name formats as job_name-N?-OMP?.
"
}

# Display job configuration
display_job_config() {
    echo "Job Configuration:"
    echo "------------------"
    echo "Number of jobs:  ${num_jobs:-N/A}"
    echo "Executable:      ${executable_path:-N/A}"
    echo "Parameter file:  ${param_file:-N/A}"

    if [[ $nodes_args_provided == true ]]; then
        echo "Nodes:           ${num_nodes:-N/A}"
        echo "MPI tasks:       ${num_mpi_tasks:-N/A}"
        echo "OMP threads:     ${num_omp_threads:-N/A}"
        echo "Wall time:       ${wall_time:-N/A}"
        echo "Queue:           ${queue_name:-N/A}"
        echo "Allocation:      ${allocation_name:-N/A}"
    fi

    echo "Subscript:       ${subscript:-N/A}"
    echo "Job name:        ${job_name:-N/A}"
}

# Submit job using slurm
submit_job_slurm() {
    # Default value for last job ID if no dependency is provided
    local last_job_id=${dependent_job_id:-NoPreviousJob}

    # Validate required variables
    if [[ -z $job_name || -z $num_jobs || -z $subscript ]]; then
        echo "Error: Required variables (job_name, num_jobs, or subscript) are not set."
        return 1
    fi

    # Loop through the number of jobs to be submitted
    for ((i = 1; i <= num_jobs; i++)); do
        # Start building the sbatch command
        local submit_command="sbatch -J $job_name \
                                     -o stdout.txt \
                                     -e stderr.txt"

        # Add resource-specific arguments if provided
        if $nodes_args_provided; then
            if [[ -z $num_nodes || -z $num_mpi_tasks || -z $wall_time || -z $queue_name || -z $allocation_name ]]; then
                echo "Error: Resource arguments (num_nodes, num_mpi_tasks, wall_time, queue_name, allocation_name) must be set when nodes_args_provided is true."
                return 1
            fi
            export OMP_NUM_THREADS=$num_omp_threads
            submit_command+=" -N $num_nodes \
                              -n $num_mpi_tasks \
                              -t $wall_time \
                              -p $queue_name \
                              -A $allocation_name"
        fi

        # Add job dependency if applicable
        [[ $last_job_id != "NoPreviousJob" ]] && submit_command+=" -d afterany:$last_job_id"

        # Add the job script
        submit_command+=" $subscript"

        # Log and execute the sbatch command
        echo
        echo "Executing sbatch command:"
        execute_command $submit_command | tee "${job_name}.last-sbatch"

        # Capture the last job ID from sbatch output
        last_job_id=$(tail -n 1 "${job_name}.last-sbatch" | awk '{ print $NF }')
    done
}

# -------------
# Main Function
# -------------

main() {
    # Default Values
    default_subscript="SubScript"

    # Help message
    if [[ "$1" == "-h" || "$1" == "--help" || -z "$1" ]]; then
        display_usage
        exit 0
    fi

    # Parse input arguments
    num_jobs=$(echo "$1" | awk -F: '{ print $1 }')
    dependent_job_id=$(echo "$1" | awk -F: '{ print $2 }')
    executable_path=$2
    param_file=$3

    # Initialize indexes and flags
    subscript_index=4
    job_name_index=5
    nodes_args_provided=false

    # Handle optional node arguments
    if [[ ${!subscript_index} =~ ^[0-9]+$ ]]; then
        nodes_args_provided=true
        num_nodes=${!subscript_index}
        num_mpi_tasks=$(eval echo \${$((subscript_index + 1))})
        num_omp_threads=$(eval echo \${$((subscript_index + 2))})
        wall_time=$(eval echo \${$((subscript_index + 3))})
        queue_name=$(eval echo \${$((subscript_index + 4))})
        allocation_name=$(eval echo \${$((subscript_index + 5))})
        subscript_index=$((subscript_index + 6))
        job_name_index=$((job_name_index + 6))
    fi

    # Parse subscript with fallback to defaults
    subscript=${!subscript_index:-$default_subscript}

    # Parse job name with fallback to defaults
    job_name=${!job_name_index:-${param_file%.par}}
    [[ "$nodes_args_provided" == true && -n "${!job_name_index}" ]] && job_name="${job_name}-N${num_nodes}-OMP${num_omp_threads}"

    # Export variables for child shells
    export SUBMITJOBS_JOBNAME="$job_name"
    export SUBMITJOBS_PARFILE="$param_file"

    # Display the job configuration
    display_job_config

    # Determine host-specific behavior
    if [[ $HOSTNAME =~ login[1-4]\.frontera\.tacc\.utexas\.edu ]]; then

        if [[ "$executable_path" = /* ]]; then
            export SUBMITJOBS_MPIRUN="ibrun $executable_path $param_file"
        else
            export SUBMITJOBS_MPIRUN="ibrun ../$executable_path $param_file"
        fi

        # Submit jobs
        submit_job_slurm

    else

        echo "Unknown host: $HOSTNAME"
        echo "This host is not configured. Exiting."

    fi
}

# Entry point
main "$@"
