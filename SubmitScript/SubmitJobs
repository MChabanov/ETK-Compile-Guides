#!/bin/bash

echo "SubmitJobs (c) 2024 Liwei Ji, Wolfgang Tichy"

# Execute and print the command
execute_command() {
    echo "\$ $@"
    "$@"
}
export -f execute_command

# ----------------
# Global Functions
# ----------------

# Generate a new directory name for a job
generate_new_directory_name() {
    # Base name for the new directory
    local base_name="${1}_r"

    # Check for existing directories matching the pattern
    if compgen -G "${base_name}[0-9][0-9][0-9][0-9]" > /dev/null; then
        # Find the highest-numbered directory
        local last_run=$(ls -d ${base_name}[0-9][0-9][0-9][0-9] 2>/dev/null | sort -V | tail -n 1)

        # Extract the numeric part of the last directory and increment it
        local last_index=${last_run##*${base_name}}
        local next_index=$((10#$last_index + 1))

        # Format the new index as a 4-digit number
        printf -v formatted_index "%04d" $next_index
        echo "${base_name}${formatted_index}"
    else
        # Default to the first directory if no matches
        echo "${base_name}0000"
    fi
}
export -f generate_new_directory_name

# Create a new job directory, move files inside, and launch jobs
create_and_organize_job_directory_and_launch_jobs() {
    local param_file=$1
    local job_name=$2
    local job_id=$3

    # Validate input arguments
    if [[ -z "$param_file" || -z "$job_name" || -z "$job_id" ]]; then
        echo "Error: Missing required arguments. Usage: create_and_organize_job_directory_and_launch_jobs <param_file> <job_name> <job_id>"
        exit 1
    fi

    # Generate a new directory name
    local job_output_dir=$(generate_new_directory_name "${job_name}")

    if [[ -d "$job_output_dir" ]]; then
        echo "Error: Directory '${job_output_dir}' already exists. Please check."
        exit 1
    fi

    execute_command mkdir -p "$job_output_dir" || { echo "Error: Failed to create directory $job_output_dir"; exit 1; }
    execute_command cp "$param_file" "$job_output_dir" || { echo "Error: Failed to copy $param_file to $job_output_dir"; exit 1; }
    execute_command mv stdout.txt "$job_output_dir" 2>/dev/null || echo "Warning: stdout.txt not found"
    execute_command mv stderr.txt "$job_output_dir" 2>/dev/null || echo "Warning: stderr.txt not found"
    # execute_command mv "$job_name.o$job_id" "$job_output_dir" 2>/dev/null || echo "Warning: $job_name.o$job_id not found"
    # execute_command mv "$job_name.e$job_id" "$job_output_dir" 2>/dev/null || echo "Warning: $job_name.e$job_id not found"

    execute_command cd "$job_output_dir" || { echo "Error: Failed to change directory to $job_output_dir"; exit 1; }

    # Launch jobs
    echo "======================================================================"
    echo "Launch MPI code..."
    echo "----------------------------------------------------------------------"
    echo "MPIRUN = $SUBMITJOBS_MPIRUN"
    echo
    echo "Job started on $(hostname) at $(date)"
    echo "======================================================================"

    time $SUBMITJOBS_MPIRUN

    if [ $? -ne 0 ]; then
      echo "Error: MPI job failed."
      exit 1
    fi

    echo "======================================================================"
    echo "Job Ended at $(date)"
}
export -f create_and_organize_job_directory_and_launch_jobs

# ---------------
# Local Functions
# ---------------

# Help message
display_usage() {
    echo "Usage: $0 -n <num_jobs:dependent_job_id> -e <executable_path> -p <param_file> [options]"
    echo ""
    echo "Required Arguments:"
    echo "  -n  Number of jobs and dependent job ID"
    echo "  -e  Path to the executable"
    echo "  -p  Path to the parameter file"
    echo ""
    echo "Optional Arguments:"
    echo "  -s  Subscript"
    echo "  OR provide all of the following:"
    echo "    -N  Number of nodes"
    echo "    -m  Number of MPI tasks"
    echo "    -o  Number of OpenMP threads"
    echo "    -w  Wall time (format: HH:MM:SS)"
    echo "    -q  Queue name"
    echo "    -a  Allocation name"
    echo ""
    echo "Additional Options:"
    echo "  -j  Job name (default: based on parameter file name)"
    echo "  -h  Display this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -n 5 -e /path/to/executable -p params.par -s MySubscript"
    echo "  $0 -n 5 -e /path/to/executable -p params.par -N 4 -m 8 -o 2 -w 02:00:00 -q high_priority -a my_project"
}

# Display job configuration
display_job_config() {
    echo "Job Configuration:"
    echo "------------------"
    echo "Number of jobs:  ${num_jobs:-N/A}"
    echo "Executable:      ${executable_path:-N/A}"
    echo "Parameter file:  ${param_file:-N/A}"

    echo "Nodes:           ${num_nodes:-N/A}"
    echo "MPI tasks:       ${num_mpi_tasks:-N/A}"
    echo "OMP threads:     ${num_omp_threads:-N/A}"
    echo "Wall time:       ${wall_time:-N/A}"
    echo "Queue:           ${queue_name:-N/A}"
    echo "Allocation:      ${allocation_name:-N/A}"

    echo "Subscript:       ${subscript:-N/A}"
    echo "Job name:        ${job_name:-N/A}"
}

# Submit job using PBS
submit_job_pbs() {
    # Default value for last job ID if no dependency is provided
    local last_job_id=${dependent_job_id:-NoPreviousJob}

    # Loop through the number of jobs to be submitted
    for ((i = 1; i <= num_jobs; i++)); do
        # Start building the qsub command
        local submit_command="qsub -N $job_name \
                                   -o stdout.txt \
                                   -e stderr.txt"

        # Add resource-specific arguments if provided
        if [[ -n $num_omp_threads ]]; then
            export OMP_NUM_THREADS=$num_omp_threads
        fi
        if [[ -n $num_nodes && -z $num_mpi_tasks ]]; then
            submit_command+=" -l select=$num_nodes:ncpus=$num_mpi_tasks"
        fi
        if [[ -n $wall_time ]]; then
            submit_command+=" -l walltime=$wall_time"
        fi
        if [[ -n $queue_name ]]; then
            submit_command+=" -q $queue_name"
        fi
        if [[ -n $allocation_name ]]; then
            submit_command+=" -A $allocation_name"
        fi

        # Add job dependency if applicable
        [[ $last_job_id != "NoPreviousJob" ]] && submit_command+=" -W depend=afterany:$last_job_id"

        # Add the job script
        submit_command+=" $subscript"

        # Log and execute the qsub command
        echo
        echo "Executing qsub command:"
        execute_command $submit_command | tee "${job_name}.last-qsub"

        # Capture the last job ID from qsub output
        last_job_id=$(tail -n 1 "${job_name}.last-qsub" | awk '{ print $NF }')
    done
}

# Function to submit jobs using Slurm
submit_job_slurm() {
    # Default value for last job ID if no dependency is provided
    local last_job_id=${dependent_job_id:-NoPreviousJob}

    # Loop through the number of jobs to be submitted
    for ((i = 1; i <= num_jobs; i++)); do
        # Start building the sbatch command
        local submit_command="sbatch -J $job_name \
                                     -o stdout.txt \
                                     -e stderr.txt"

        # Add resource-specific arguments if provided
        [[ -n $num_omp_threads ]] && export OMP_NUM_THREADS=$num_omp_threads
        [[ -n $num_nodes ]] && submit_command+=" -N $num_nodes"
        [[ -n $num_mpi_tasks ]] && submit_command+=" -n $num_mpi_tasks"
        [[ -n $wall_time ]] && submit_command+=" -t $wall_time"
        [[ -n $queue_name ]] && submit_command+=" -p $queue_name"
        [[ -n $allocation_name ]] && submit_command+=" -A $allocation_name"

        # Add job dependency if applicable
        [[ $last_job_id != "NoPreviousJob" ]] && submit_command+=" -d afterany:$last_job_id"

        # Add the job script
        submit_command+=" $subscript"

        # Log and execute the sbatch command
        echo
        echo "Executing sbatch command:"
        execute_command $submit_command | tee "${job_name}.last-sbatch"

        # Capture the last job ID from sbatch output
        last_job_id=$(tail -n 1 "${job_name}.last-sbatch" | awk '{ print $NF }')
    done
}

# -------------
# Main Function
# -------------

main() {
    # Default Values
    default_subscript="SubScript"

    # Parse command-line arguments
    while getopts ":n:e:p:N:m:o:w:q:a:s:j:h" opt; do
        case $opt in
            n) num_jobs_dependent_job_id="$OPTARG" ;;
            e) executable_path="$OPTARG" ;;
            p) param_file="$OPTARG" ;;
            N) num_nodes="$OPTARG" ;;
            m) num_mpi_tasks="$OPTARG" ;;
            o) num_omp_threads="$OPTARG" ;;
            w) wall_time="$OPTARG" ;;
            q) queue_name="$OPTARG" ;;
            a) allocation_name="$OPTARG" ;;
            s) subscript="$OPTARG" ;;
            j) job_name="$OPTARG" ;;
            h) display_usage; exit 0 ;;
            :) echo "Error: Option -$OPTARG requires an argument." >&2; display_usage; exit 1 ;;
            \?) echo "Error: Invalid option -$OPTARG" >&2; display_usage; exit 1 ;;
        esac
    done

    # Ensure required arguments are provided
    if [[ -z "$num_jobs_dependent_job_id" || -z "$executable_path" || -z "$param_file" ]]; then
        echo "Error: Missing required arguments." >&2
        display_usage
        exit 1
    fi

    # Parse input arguments
    num_jobs=$(echo "$num_jobs_dependent_job_id" | awk -F: '{ print $1 }')
    dependent_job_id=$(echo "$num_jobs_dependent_job_id" | awk -F: '{ print $2 }')

    # Parse subscript with fallback to defaults
    subscript=${subscript:-$default_subscript}

    # Parse job name with fallback to defaults
    job_name=${job_name:-${param_file%.par}}
    [[ -n "${job_name}" && -n "${num_nodes}" && -n "${num_omp_threads}" ]] && job_name="${job_name}-N${num_nodes}-OMP${num_omp_threads}"

    # Export variables for child shells
    export SUBMITJOBS_JOBNAME="$job_name"
    export SUBMITJOBS_PARFILE="$param_file"

    # Display the job configuration
    display_job_config

    # Determine host-specific behavior
    if [[ $HOSTNAME =~ login[1-4]\.frontera\.tacc\.utexas\.edu ]]; then

        if [[ "$executable_path" = /* ]]; then
            export SUBMITJOBS_MPIRUN="ibrun $executable_path $param_file"
        else
            export SUBMITJOBS_MPIRUN="ibrun ../$executable_path $param_file"
        fi

        # Submit jobs
        submit_job_slurm

    elif [[ $HOSTNAME =~ green-prairies.cluster ]]; then

        if [[ "$executable_path" = /* ]]; then
            export SUBMITJOBS_MPIRUN="mpiexec.hydra -machinefile $PBS_NODEFILE -np $(wc -l < "$PBS_NODEFILE") $executable_path $param_file"
        else
            export SUBMITJOBS_MPIRUN="mpiexec.hydra -machinefile $PBS_NODEFILE -np $(wc -l < "$PBS_NODEFILE") ../$executable_path $param_file"
        fi

        # Submit jobs
        submit_job_pbs

    else

        echo "Unknown host: $HOSTNAME"
        echo "This host is not configured. Exiting."

    fi
}

# Entry point
main "$@"
